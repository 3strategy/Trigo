---
layout: default
title: Trigo Trainer
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
  <title>Triangle Trainer</title>
</head>
<body>
  <h2>Trigo Trainer   <input type="text" id="name-input" placeholder="Enter your name (optional)"/></h2>
  <!-- <div class="device-toggle">
    <label>
      <input type="radio" name="device" value="desktop" checked> Desktop
    </label>
    <label>
      <input type="radio" name="device" value="mobile"> Mobile
    </label>
  </div> -->

  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>

  <div id="status-message"></div>

  <div id="answer-buttons" class="math-button">
    <button class="btn" data-value="1">\[a\sin\beta\]</button>
    <button class="btn" data-value="2">\[a\cos\beta\]</button>
  </div>
  <div id="answer-buttons" class="math-button">
    <button class="btn" data-value="11">\[\frac{a}{\sin\beta}\]</button>
    <button class="btn" data-value="22">\[\frac{a}{\cos\beta}\]</button>
    <button class="btn" data-value="9" style="background-color: #db4437;">Finish</button>
  </div>

  <div id="results" class="hidden">
    <h2>Results</h2>
    <div id="result-text"></div>
    <button id="restart-btn" class="btn" style="margin-top: 15px; background-color: #0f9d58;">Restart</button>
  </div>

  <script>
    window.onload = function() {
      MathJax.typeset();
    }

    document.addEventListener("DOMContentLoaded", function() {
      // Canvas setup
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const canvasContainer = document.getElementById("canvas-container");
      const statusMessage = document.getElementById("status-message");
      const resultsDiv = document.getElementById("results");
      const resultText = document.getElementById("result-text");
      const nameInput = document.getElementById("name-input");

      // Tracking variables
      let flag = true;
      let total = 0;
      let counter = 0;
      let timetaken = 0;
      let c1 = 0, c2 = 0, c11 = 0, c22 = 0;
      let t1 = 0, t2 = 0, t11 = 0, t22 = 0;
      let tm = 0, td = 0;
      let starttime = 0;
      let mobileMode = false;

      // Colors
      const cred = 'red';
      const cblue = 'blue';
      const cblack = 'black';
      const cgreen = 'lightgreen';

      // Set up canvas dimensions
      function setupCanvas() {
        let maxx = mobileMode ? 250 : 600;
        let maxy = mobileMode ? 350 : 500;

        // Instead of using maxx/2 for center, define the actual canvas dimension
        const canvasWidth = maxx + 10;
        const canvasHeight = maxy + 10;

        // Now set the canvas size
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Adjust status message dimension
        statusMessage.style.width = canvasWidth + "px";
        statusMessage.style.height = "70px";

        // Container size
        canvasContainer.style.width = canvasWidth + "px";
        canvasContainer.style.height = canvasHeight + "px";

        // Fill background
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Handle device toggle (if needed)
      const deviceRadios = document.querySelectorAll('input[name="device"]');
      deviceRadios.forEach(function(radio) {
        radio.addEventListener("change", function(e) {
          mobileMode = e.target.value === 'mobile';
          setupCanvas();
          if (flag) {
            setTimeout(triangle1, 100); // Redraw triangle with new dimensions
          }
        });
      });

      // Initialize
      setupCanvas();

      // Helper functions
      function drawLine(x1, y1, x2, y2, color = cblue, width = mobileMode ? 2 : 4) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
      }

      function writeText(x, y, text, color = cblue) {
        const fontSize = mobileMode ? 48 : 50;
        const fontStyle = mobileMode ? 'italic' : 'italic';
        ctx.font = `${fontStyle} ${fontSize}px Arial`;
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
      }

      // Main triangle drawing function with centering
      function triangle1() {
        if (!flag) return;
        // Clear canvas
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // We'll use the actual canvas dimension for the center
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        // The true center is half of the actual canvas size
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;

        // Set parameters
        const sinn = Math.random() > 0.5 ? 1 : 0;
        const is_division = Math.random() > 0.5 ? 1 : 0;
        const sc = mobileMode ? 0.4 : 1;
        const xora = is_division === 0 ? ['a', 'x?'] : ['x?', 'a'];

        // Generate random parameters for the triangle’s shape
        // (Same logic as before)
        let dx = (sc * 90 + (Math.random() - 0.5) * sc * 140) * (Math.random() > 0.5 ? -1 : 1);
        let l1 = Math.pow(Math.min(centerX, centerY) * 1.2, 2);
        if (sc !== 1) l1 *= 0.7;
        let dy = Math.sqrt(Math.max(l1 - dx * dx, 0)) * (Math.random() > 0.5 ? -1 : 1);
        const ratio = (0.55 + 0.25 * Math.random()) * (Math.random() > 0.5 ? -1 : 1);

        // Compute the three vertices BEFORE centering
        let A_x = centerX - 0.5 * dx;
        let A_y = centerY - 0.5 * dy;
        let B_x = A_x + dx;
        let B_y = A_y + dy;

        const newDx = dx * ratio;
        const newDy = dy * ratio;
        let C_x = B_x + newDy;
        let C_y = B_y - newDx;

        // Compute centroid of triangle (A, B, C)
        const centroid_x = (A_x + B_x + C_x) / 3;
        const centroid_y = (A_y + B_y + C_y) / 3;

        // Shift all vertices so the centroid is at centerX, centerY
        const delta_x = centerX - centroid_x;
        const delta_y = centerY - centroid_y;
        A_x += delta_x; A_y += delta_y;
        B_x += delta_x; B_y += delta_y;
        C_x += delta_x; C_y += delta_y;

        // Compute midpoints for labeling
        const x0 = (A_x + B_x) / 2; 
        const y0 = (A_y + B_y) / 2;
        const x1 = (A_x + C_x) / 2; 
        const y1 = (A_y + C_y) / 2;

        // Draw the triangle edges
        drawLine(A_x, A_y, B_x, B_y);
        drawLine(B_x, B_y, C_x, C_y);
        drawLine(A_x, A_y, C_x, C_y);

        // Right-angle marker at B
        const L = Math.sqrt(dx * dx + dy * dy);
        const k = sc * 20 / (L || 1);
        const u1x = -dx / L, u1y = -dy / L;
        const BC_length = Math.sqrt(newDx * newDx + newDy * newDy);
        const u2x = newDy / (BC_length || 1), u2y = -newDx / (BC_length || 1);

        const P_x = B_x + k * u1x;
        const P_y = B_y + k * u1y;
        const Q_x = B_x + k * u2x;
        const Q_y = B_y + k * u2y;
        drawLine(P_x, P_y, Q_x, Q_y, cred);

        // β label: A or C
        let xb, yb;
        if (sinn === 0) {
          xb = A_x;
          yb = A_y;
        } else {
          xb = C_x;
          yb = C_y;
        }
        writeText(xb, yb, 'β', cgreen);
        writeText(x0, y0, xora[0], cred);
        writeText(x1, y1, xora[1], cred);

        // Determine correct answer
        let correct;
        if (is_division === 1) {
          correct = sinn === 1 ? 1 : 2;
        } else {
          correct = sinn === 1 ? 11 : 22;
        }
        canvas.dataset.correctAnswer = correct.toString();
        starttime = performance.now();
      }

      // Handle button clicks
      document.querySelectorAll('.btn').forEach(function(button) {
        button.addEventListener('click', function() {
          if (!flag) return;
          const value = parseInt(this.getAttribute('data-value') || '0');
          handleAnswer(value);
        });
      });

      function handleAnswer(ans) {
        if (!flag) return;
        const correct = parseInt(canvas.dataset.correctAnswer || '0');
        const elapsedTime = (performance.now() - starttime) / 1000;
        timetaken += elapsedTime;
        total += 1;
        if (total > 22 || timetaken > 360) {
          handleAnswer(9);
          return;
        }
        // Update counters
        if (correct === 1 || correct === 2) {
          td += elapsedTime;
          if (correct === 1) {
            if (ans === correct) c1 += 1;
            if (ans !== 9) t1 += 1;
          } else {
            if (ans === correct) c2 += 1;
            if (ans !== 9) t2 += 1;
          }
        } else {
          tm += elapsedTime;
          if (correct === 11) {
            if (ans === correct) c11 += 1;
            if (ans !== 9) t11 += 1;
          } else {
            if (ans === correct) c22 += 1;
            if (ans !== 9) t22 += 1;
          }
        }

        // Provide feedback
        if (ans === correct) {
          statusMessage.textContent = "Great!";
          statusMessage.style.color = cgreen;
          counter += 1;
          setTimeout(() => {
            statusMessage.textContent = "";
            triangle1();
          }, 2000);
        } else if (ans === 9) {
          flag = false;
          total -= 1;
          showResults();
        } else {
          statusMessage.textContent = "Incorrect";
          statusMessage.style.color = "gray";
          setTimeout(() => {
            statusMessage.textContent = "";
            triangle1();
          }, 2000);
        }
      }

      function showResults() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const name = nameInput.value.trim() || "Anonymous";
        let resultString = `Thanks ${name}. ${counter} correct of ${total}\n`;
        resultString += `Avg response time is ${(timetaken/Math.max(1, total)).toFixed(1)}\n`;
        if (t1 > 0) {
          resultString += `\n${c1} correct sin multiplications (${(100*c1/t1).toFixed(1)}%)`;
        } else {
          resultString += `\nN/A correct sin multiplications (N/A%)`;
        }
        if (t2 > 0) {
          resultString += `\n${c2} correct cos multiplications (${(100*c2/t2).toFixed(1)}%)`;
        } else {
          resultString += `\nN/A correct cos multiplications (N/A%)`;
        }
        if (t11 > 0) {
          resultString += `\n${c11} correct sin divisions (${(100*c11/t11).toFixed(1)}%)`;
        } else {
          resultString += `\nN/A correct sin divisions (N/A%)`;
        }
        if (t22 > 0) {
          resultString += `\n${c22} correct cos divisions (${(100*c22/t22).toFixed(1)}%)`;
        } else {
          resultString += `\nN/A correct cos divisions (N/A%)`;
        }
        if (t11 + t22 > 0) {
          resultString += `\nAvg time for divisions: ${(td/(t11+t22)).toFixed(1)}`;
        } else {
          resultString += `\nAvg time for divisions: N/A`;
        }
        if (t1 + t2 > 0) {
          resultString += `\nAvg time for multiplications: ${(tm/(t1+t2)).toFixed(1)}`;
        } else {
          resultString += `\nAvg time for multiplications: N/A`;
        }
        resultText.textContent = resultString;
        resultsDiv.classList.remove("hidden");
        sendResultsToTelegram(resultString, name);
      }

      async function sendResultsToTelegram(results, name) {
        try {
          const message = `${results}\n${new Date().toLocaleString()}\n${name}\n${tm}, ${td}, ${timetaken}`;
          const response = await fetch("https://super-term-2809.3strategy.workers.dev/", { 
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message })
          });
          if (response.ok) {
            console.log("Results sent successfully");
          } else {
            console.error("Failed to send results:", await response.text());
          }
        } catch (error) {
          console.error("Failed to send results:", error);
        }
      }

      document.getElementById("restart-btn").addEventListener("click", function() {
        flag = true;
        total = 0;
        counter = 0;
        timetaken = 0;
        c1 = 0; c2 = 0; c11 = 0; c22 = 0;
        t1 = 0; t2 = 0; t11 = 0; t22 = 0;
        tm = 0; td = 0;
        resultsDiv.classList.add("hidden");
        triangle1();
      });

      setTimeout(triangle1, 100);
    });
  </script>
  
</body>
</html>
